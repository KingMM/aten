#include "sampler/halton.h"
#include "math/math.h"
#include "defs.h"

namespace aten {
	std::vector<uint32_t> Halton::PrimeNumbers;

	// 素数生成.
	void Halton::makePrimeNumbers(uint32_t maxNumber/*= MaxPrimeNumbers*/)
	{
		// エラトステネスの篩（ふるい）.
		// https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9

		// アルゴリズム.
		// ステップ 1.
		//		探索リストに2からxまでの整数を昇順で入れる.
		// ステップ 2.
		//		探索リストの先頭の数を素数リストに移動し、その倍数を探索リストから篩い落とす.
		// ステップ 3.
		//		上記の篩い落とし操作を探索リストの先頭値がxの平方根に達するまで行う.
		// ステップ 4.
		//		探索リストに残った数を素数リストに移動して処理終了.

		// 具体例　x=120 の場合
		// ステップ 1
		//		探索リスト = { 2から120まで }、探索リストの先頭値 = 2
		// ステップ 2 - 1
		//		素数リスト = { 2 }
		//		探索リスト = { 3から119までの奇数 }、探索リストの先頭値 = 3
		// ステップ 2 - 2
		//		素数リスト = { 2,3 }
		//		探索リスト = { 5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,83,85,89,91,95,97,101,103,107,109,113,115,119 }
		//		探索リストの先頭値 = 5
		// ステップ 2 - 3
		//		素数リスト = { 2,3,5 }
		//		探索リスト = { 7,11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67,71,73,77,79,83,89,91,97,101,103,107,109,113,119 }
		//		探索リストの先頭値 = 7
		// ステップ 2 - 4
		//		素数リスト = { 2,3,5,7 }
		//		探索リスト = { 11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113 }
		//		探索リストの先頭値 = 11
		// ステップ 3
		//		探索リストの先頭値が sqrt(120) = 10.954 に達しているのでステップ4へ.
		// ステップ 4
		//		残った探索リストを素数リストに移動.
		//		素数リスト = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113 }

		
		uint32_t N = aten::clamp<uint32_t>(maxNumber, 2, MaxPrimeNumbers);

		// 探索リスト.
		//  0 : 素数リストに入る.
		//  1 : 素数リストに入らない.
		// まずは、すべて素数リストに入る可能性があるので、すべてゼロにしておく.
		std::vector<uint32_t> table;
		table.resize(N + 1, 0);

		// アルゴリズムとして 2 から始まる.

		// 探索リストの先頭の値が sqrt(N) に達したら終了.
		// -> sqrt(N) の倍数について探索したら終了.
		//    なぜなら、sqrt(N) の倍数について探索した時点で、sqrt(N) の倍数はふるいにかけられるので、先頭値は必ず、sqrt(N) の倍数を超える.
		// -> i は探索候補の数値になるので、i が sqrt(N) を超えるまで探索を続ければいいことになる.

		for (uint32_t i = 2; i * i <= N; i++) {
			if (table[i] == 0) {
				// iが素数リストに入る.

				// iの倍数をふるいにかける.
				//  i に i を足すと、i の次の i の倍数となる.
				//  i に i を足し続ければ、i の倍数となる.
				for (uint32_t n = i + i; n <= N; n += i) {
					table[n] = 1;
				}
			}
		}

		// 最終的な素数リストに格納.
		for (uint32_t i = 2; i <= N; i++) {
			if (table[i] == 0) {
				// 0 なので、素数リスト入り.
				PrimeNumbers.push_back(i);
			}
		}
	}

	real Halton::nextSample()
	{
		// NOTE
		// https://en.wikipedia.org/wiki/Halton_sequence

		if (m_param.dimension >= PrimeNumbers.size()) {
			// 次元を超えることは許さない..
			AT_ASSERT(false);
			return aten::drand48();
		}

		real f = 1;
		real r = 0;

		const auto base = PrimeNumbers[m_param.dimension++];

		uint32_t i = m_param.idx;

		while (i > 0) {
			f = f / (real)base;
			r = r + f * (i % base);
			i = i / base;
		}

		return r;
	}
}
